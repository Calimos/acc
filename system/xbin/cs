#!/system/bin/sh
# Magic Charging Switch (cs)
# VR25 @ XDA Developers



# ENVIRONMENT & TOOLBOX

# Add Magisk built-in busybox to PATH
export PATH="/sbin/.core/busybox:/dev/magisk/bin:$PATH"

# Root check
if ! id | grep -qi 'uid=0(root)'; then
	echo -e "\n(!) cs must be run as root.\n"
	exit 1
else
	echo
fi

PersistDir="/data/media/cs"
config="$PersistDir/config"


# Laziness can be [very] friendly
is() { [ -$1 "$2" ]; }
n() { [ -n "$1" ]; }
z() { [ -z "$1" ]; }
gt() { [ "$1" -gt "$2" ]; }
ge() { [ "$1" -ge "$2" ]; }
lt() { [ "$1" -lt "$2" ]; }
le() { [ "$1" -le "$2" ]; }
eq() { [ "$1" -eq "$2" ]; }


grep_prop() {
	FILE="$2"
	z "$FILE" && FILE="/system/build.prop"
	sed -n "s/^$1=//p" "$FILE"
}


# Find ModPath
for n in 0 1 2 3 4 5 6 7; do
	if losetup /dev/block/loop$n 2>/dev/null | grep -q '/data/magisk.img'; then
		for MountPoint in `grep /dev/block/loop$n /proc/mounts | cut -d' ' -f2 | grep -v '/system'`; do
			if is f $MountPoint/cs/module.prop; then
				ModPath=$MountPoint/cs
				break
			fi
		done
	fi
done

if ! is f "$ModPath/module.prop"; then
  echo -e "\n(!) cs path not found\n"
  exit 1
fi


DEVICE="`grep_prop ro.product.brand`-`grep_prop ro.product.device`"


csVersion="`grep_prop versionCode $ModPath/module.prop`"


verbose_log="$PersistDir/cs_verbose-$DEVICE.log"
last_verbose_log="$PersistDir/last_cs_verbose-$DEVICE.log"


z "$service_is_running" && service_is_running=false


# Verbose logger
is f "$verbose_log" && mv "$verbose_log" "$last_verbose_log"
if is f $PersistDir/enable_verbose; then

	if ! $service_is_running && [ "$1" != "-v" ]; then
		echo "(!) WARNING: verbose is enabled."
		echo "- Don't forget to disable it after finishing debugging."
		echo -e "- Else, in the long run, your device's internal storage will be filled up and system will eventually crash or freeze!\n"
		sleep 7
	fi

	grep -i product /system/build.prop > "$verbose_log"
	echo >> "$verbose_log"
	echo -e "csVersion=$csVersion\n" >> "$verbose_log"
	set -x 2>>"$verbose_log"
fi


debug() {
	if ! is f $PersistDir/enable_verbose; then
		is f "$verbose_log" && mv "$verbose_log" "$last_verbose_log"
		grep -i product /system/build.prop > "$verbose_log"
		echo >> "$verbose_log"
		echo -e "csVersion=$csVersion\n" >> "$verbose_log"
		set -x 2>>"$verbose_log"
	fi
	
	echo "(i) Gathering debugging data..."
	PATH="$PATH:$ModPath/bin"
	#if sestatus | grep -qi enforcing; then setenforce 0; se_0=false; else se_0=true; fi
	rm -rf /data/cs_debug* /sdcard/cs_debug* 2>/dev/null
	mkdir /data/cs_debug
	cd /data/cs_debug || { echo "(!) Couldn't cd /data/cd_debug"; exit 1; }
	grep -i product /system/build.prop > cs_debug.log
	echo >> cs_debug.log
	echo -e "csVersion=$csVersion\n" >> cs_debug.log
	
	is f $PersistDir/sys_cache || find /sys 2>/dev/null | grep -iv log | grep -Ei 'batt|charg' > $PersistDir/sys_cache
	cat $PersistDir/sys_cache >> cs_debug.log
	zip -9qq cs_debug.zip cs_debug.log 2>/dev/null
	zip -9qqu cs_debug.zip $PersistDir/* -x $PersistDir/sys_cache 2>/dev/null
	
	for TARGET in `cat $PersistDir/sys_cache`; do
		zip -9qqu cs_debug.zip "$TARGET" 2>/dev/null
	done
	
	mv cs_debug.zip "/sdcard/cs_debug-$DEVICE.zip" 2>/dev/null
	is f "/sdcard/cs_debug-$DEVICE.zip" || mv cs_debug.log "/sdcard/cs_debug-$DEVICE.log"
	chmod 777 /sdcard/cs_debug*
	rm -rf /data/cs_debug 2>/dev/null
	echo -e "- Done.\n"
	file_type() { echo -e "(i) Please upload /sdcard/cs_debug-$DEVICE.$1 to the official XDA thread.\n"; }
	if is f "/sdcard/cs_debug-$DEVICE.zip"; then file_type zip; else file_type log; fi
	#$se_0 || setenforce 1
	exit 0
}



# CHARGING CONTROL FUNCTIONS

# Charging info
c_info() {
	cat "$uevent" | grep -vE 'NAME|STATUS|PRESENT|HEALTH|COUNTER|CAPACITY_LEVEL' \
		| sed 's/POWER_SUPPLY_//' \
		| sed 's/CAPACITY/LEVEL/' \
		| sed '/LEVEL=/s/$/%/' \
		| sed 's/_NOW//' \
		| sed '/RGE_R/s/GE/GING/'
	echo
}


# Charging loop
c_loop() {
	switch_ON
	until auto_run && ! pause_svc; do
		until ge "$batt_level" "$1"; do
			clear
			get_batt_level
			echo "Charging to $1%..."
			echo -e "$start_time\n"
			c_info
			echo "(i) Press CTRL (Vol. Down) + C to abort."
			if ge "$batt_level" 75; then sleep 25; else sleep 60; fi
		done

		switch_OFF
		echo -e "\n(i) Desired charge % reached."
		end_time
		# Reset battery stats
		dumpsys batterystats --reset &>/dev/null
		echo -e "- Charging paused; battery stats cleared.\n"
		echo "(i) Waiting until $lower_limit% to restart the cycle..."
		echo "- Press CTRL (Vol. Down) + C to abort."
		until le "$batt_level" "$lower_limit"; do
			get_batt_level
			if le "$batt_level" 25; then sleep 25; else sleep 60; fi
		done
		switch_ON
	done
	exit 0
}


get_ctrl_files() {
	if is f $PersistDir/manual_ctrl; then . $PersistDir/manual_ctrl

	else
		echo "(i) Checking compatibility..."
		is f $PersistDir/sys_cache || find /sys 2>/dev/null | grep -iv log | grep -Ei 'batt|charg' > $PersistDir/sys_cache
		
		while read uevent_file; do
			if grep -qs '^POWER_SUPPLY_CAPACITY=' "$uevent_file"; then
				uevent="$uevent_file"
				break
			fi
		done <<< "`cat $PersistDir/sys_cache | grep -i 'battery/uevent'`"
		
		if ! is f "$uevent"; then
			echo -e "\n(!) Unsupported device\n"
			debug
		fi
		
		while read ctrl_file; do
			if echo "$ctrl_file" | grep -q ' '; then
				if grep -Eiq "`echo "$ctrl_file" | cut -d' ' -f1`" $PersistDir/sys_cache; then ctrl_file_found=true; else ctrl_file_found=false; fi
			else
				if grep -Eiq "$ctrl_file" $PersistDir/sys_cache; then ctrl_file_found=true; else ctrl_file_found=false; fi
			fi
			if $ctrl_file_found; then
				if echo "$ctrl_file" | grep -q ' '; then
					SWITCH `grep -Ei "\`echo "$ctrl_file" | cut -d' ' -f1\`" $PersistDir/sys_cache | head -n 1` `echo "$ctrl_file" | cut -d' ' -f2,3`
				else
					SWITCH `grep -Ei "$ctrl_file" $PersistDir/sys_cache | head -n 1`
				fi
				is f "$SWITCH" && switch_OFF
				charging || break
			fi
		done <<< "`grep -Ev '#|^$' $ModPath/config/ctrl_files_db`"

		if ! is f "$SWITCH" || charging; then
			echo -e "\n(!) Unsupported device\n"
			debug
		fi
		switch_ON
		echo -e "- OK\n"
	fi
}


exxit() {
	echo "(!) Invalid option/argument"
	echo -e "- Run \"cs -h\" for help\n"
	exit 1
}


start_time() { echo "- Start time: `date +'%F %T'`"; }
end_time() { echo "- End time: `date +'%F %T'`"; }


SWITCH() {
	SWITCH="$1"
	if n "$2"; then
		c_ON=$2
		c_OFF=$3
	else
		c_ON=1
		c_OFF=0
	fi
}


OFF_time() {
	if $invert_OFF; then switch_ON; else switch_OFF; fi
	if n "$1"; then
		if echo "$1" | grep -q '[a-z]'; then
		
			if $invert_OFF; then
				echo "(i) Charging enabled for $1."
				start_time
			else
				echo "(i) Charging disabled for $1."
				end_time
			fi
			
			if echo "$1" | grep -q 'm'; then
				sleep $(( 60 * `echo $1 | sed 's/m//'` ))
			elif echo "$1" | grep -q 'h'; then
				sleep $(( 3600 * `echo $1 | sed 's/h//'` ))
			else exxit
			fi
		elif ! echo "$1" | grep -q '[a-z]' \
			&& echo "$1" | grep -q '[0-9]'; then
			
			if $invert_OFF; then
				echo "(i) Charging enabled for $1s."
				start_time
			else
				echo "(i) Charging disabled for $1s."
				end_time
			fi
			sleep $1
		fi
		echo
		echo '(i) Timeount reached.'
		
		if $invert_OFF; then
			switch_OFF
			echo '- Charging disabled.'
			end_time
		else
			switch_ON
			echo '- Charging re-enabled'
			start_time
		fi
		
	else
		if $invert_OFF; then
			echo '(i) Charging enabled.'
		else
			echo '(i) Charging disabled.'
		fi
	fi
	echo
}


OFF_percent() {
	if $invert_OFF; then
		switch_ON
		echo "(i) Charging enabled until $1."
		start_time
	else
		switch_OFF
		echo "(i) Charging disabled until $1."
		end_time
	fi

	echo
	until eq "$batt_level" "`echo $1 | sed 's/%//'`"; do
		get_batt_level
		sleep 10
	done
	echo '(i) Desired % reached.'
		
	if $invert_OFF; then
		switch_OFF
		echo '- Charging disabled.'
		end_time
	else
		switch_ON
		echo '- Charging re-enabled'
		start_time
	fi
	echo
}


auto_run() { is f $PersistDir/auto_run; }
pause_svc() { is f $PersistDir/pause_svc; }
charging() { grep -iq '=charging$' "$uevent"; }
get_batt_level() { read batt_level <<< "`cat "\`dirname "$uevent"\`/capacity"`"; }

switch_OFF() { echo $c_OFF > "$SWITCH"; }
switch_ON() { echo $c_ON > "$SWITCH"; }

get_limits() {
	read higher_limit <<< "`grep_prop 'higher_limit' $config`"
	read lower_limit <<< "`grep_prop 'lower_limit' $config`"
}


# Update config
update_cfg() {
	is f $config && . $config
	is f $PersistDir/manual_ctrl && . $PersistDir/manual_ctrl
	rm $config 2>/dev/null
	
	if is f $config && z "$1"; then
		echo "higher_limit=$higher_limit" >> $config
		echo "lower_limit=$lower_limit" >> $config
	else
		if n "$1"; then echo higher_limit=$1 >> $config; else echo higher_limit=90 >> $config; fi
		if n "$2"; then echo lower_limit=$2 >> $config; else echo lower_limit=80 >> $config; fi
	fi
	
	echo "uevent=\"$uevent\"" >> $config
	echo "SWITCH \"$SWITCH\" $c_ON $c_OFF" >> $config
	. $config
	get_batt_level
}



# ENGINE

# Pre-ignition
is d $PersistDir || mkdir $PersistDir
if ! echo "$1" | grep -Eq '\-c|\-h|\-r|\-v|debug'; then
	is f $config && . $config || get_ctrl_files
	get_batt_level
	if ! auto_run || pause_svc; then read start_time <<< "`start_time`"; fi
	invert_OFF=false
fi


# Manually set charging ctrl config
if [ "$1" = "-c" ]; then
	if z "$2"; then
		echo "(!) Missing argument(s)"
		echo "- Syntax: \"cs -c /path/to/ctrl/file ON OFF\""
		echo -e "-- \"ON OFF\" defaults: 1 0\n"
		exit 1
	fi
		
	echo "SWITCH \"$2\" $3 $4" > $PersistDir/manual_ctrl
	echo "(i) Checking compatibility..."
	is f $PersistDir/sys_cache || find /sys 2>/dev/null | grep -iv log | grep -Ei 'batt|charg' > $PersistDir/sys_cache
	
	for uevent_file in `cat $PersistDir/sys_cache | grep -i 'battery/uevent'`; do
		if grep -qs '^POWER_SUPPLY_CAPACITY=' "$uevent_file"; then
			echo "uevent=\"$uevent_file\"" >> $PersistDir/manual_ctrl
			break
		fi
	done
	
	. $PersistDir/manual_ctrl
	is f "$SWITCH" && switch_OFF
	if ! is f "$SWITCH" || charging; then
		echo -e "\n(!) Incompatible control file\n"
	
		if ! is f "$uevent"; then
			echo -e "\n(!) Battery uevent file not found\n"
			echo -e "- Unsupported device\n"
			rm $PersistDir/manual_ctrl
			debug
		fi
			
		rm $PersistDir/manual_ctrl
		echo
		exit 1
	fi
		
	if ! is f "$uevent"; then
		echo -e "\n(!) Battery uevent file not found\n"
		echo -e "- Unsupported device\n"
		rm $PersistDir/manual_ctrl
		debug
	fi
	
	switch_ON
	update_cfg
	echo -e "- All set.\n"
	exit 0
		

# Toggle store_mode/batt_slate_mode (Samsung); charging_enabled/battery_charging_enabled (others)
elif [ "$1" = "-x" ]; then
	is f $config || update_cfg
	if grep -q 'store_mode' $config; then
		sed -i 's/store_mode/batt_slate_mode/' $config
		echo -e "store_mode --> batt_slate_mode\n"
	elif grep -q 'batt_slate_mode' $config; then
		sed -i 's/batt_slate_mode/store_mode/' $config
		echo -e "batt_slate_mode --> store_mode\n"
	elif grep -q '/charging_enabled' $config; then
		sed -i 's/\/charging_enabled/\/battery_charging_enabled/' $config
		echo -e "charging_enabled --> battery_charging_enabled\n"
	elif grep -q 'battery_charging_enabled' $config; then
		sed -i 's/battery_charging_enabled/charging_enabled/' $config
		echo -e "battery_charging_enabled --> charging_enabled\n"
	else
		echo -e "(i) This feature doesn't apply to your device.\n"
	fi
	exit 0


elif [ "$1" = 'debug' ]; then debug


# Toggle verbose
elif [ "$1" = "-v" ]; then
	if is f $PersistDir/enable_verbose; then
		rm $PersistDir/enable_verbose
		echo "(i) verbose OFF"
		if auto_run && ! pause_svc; then
			rm $PersistDir/auto_run
			echo "- CS service stopped."
		fi
	else
		touch $PersistDir/enable_verbose
		echo -e "(i) verbose ON\n"
		echo "(!) WARNING: don't forget to disable this after finishing debugging."
		echo "- Else, in the long run, your device's internal storage will be filled up and system will eventually crash or freeze!"
	fi
	echo
	exit 0


# Toggle Auto-run
elif [ "$1" = "-s" ]; then
	if pause_svc; then
		rm $PersistDir/pause_svc
		switch_ON
		echo "(i) CS service resumed."
	else
		if auto_run; then
			rm $PersistDir/auto_run
			echo "(i) CS service OFF"
		else
			touch $PersistDir/auto_run
			echo "(i) CS service ON"
			echo "- Reboot to apply change."
		fi
	fi
	echo
	exit 0


# Keep/maintain battery power at a constant level
elif [ "$1" = '-k' ]; then
	if auto_run && ! pause_svc; then
		touch $PersistDir/pause_svc
		echo "(i) CS service paused."
		echo "- Reboot the system or simply run \"cs -s\" to resume."
		echo
	fi
	
	echo "Maintaining $2%..."
	echo "(i) Press CTRL (Vol. Down) + C to abort."
	switch_ON

	while :; do
		until ge "$batt_level" "$2" || ! charging; do
			sleep 25
			get_batt_level
		done
		ge "$batt_level" "$2" && switch_OFF
	
		until le "$batt_level" "$2" || charging; do
			sleep 60
			get_batt_level
		done
		le "$batt_level" "$2" && switch_ON
	done
	exit 0


# Reset battery stats on demand
elif [ "$1" = "-b" ]; then
	dumpsys batterystats --reset
	echo
	exit 0
	

# Reset cs
elif [ "$1" = "-r" ]; then
	for f in $PersistDir/*; do rm "$f" 2>/dev/null; done
	echo -e "(i) cs has been reset to its initial state.\n"
	exit 0


# CS service
elif [ "$1" = "service" ]; then
	auto_run || exit 0
	touch > $PersistDir/last_service_run
	is f $config || update_cfg
	switch_ON
	
	if is f $PersistDir/enable_verbose; then ###
		get_limits
		echo "higher_limit=$higher_limit"
		echo "lower_limit=$lower_limit"
	fi

	while auto_run; do
		while auto_run && lt "$batt_level" "$higher_limit" && charging; do
			is f $PersistDir/enable_verbose && echo "Waiting until $higher_limit%..." ###
			get_limits
			get_batt_level
			if ge "$batt_level" 75; then sleep 25; else sleep 60; fi
		done
		if ge "$batt_level" "$higher_limit" && auto_run && ! pause_svc; then
			switch_OFF
			dumpsys batterystats --reset &>/dev/null
		fi

		while auto_run && gt "$batt_level" "$lower_limit" && ! charging; do
			is f $PersistDir/enable_verbose && echo "Waiting until $lower_limit%..." ###
			get_limits
			get_batt_level
			if le "$batt_level" 25; then sleep 25; else sleep 60; fi
		done
		if le "$batt_level" "$lower_limit" && auto_run && ! pause_svc; then
			switch_ON
		fi
	done
	exit 0


# Usage instructions
elif [ "$1" = "-h" ]; then
	cat <<EOD
Magic Charging Switch (cs)

Automatically pauses/resumes charging at set time intervals and/or % levels to extend battery lifespan.


Usage:

cs [b] [-c] [-h] [-i] [-r] [-s] [-v] [-x] [debug] [-k LEVEL] [PAUSE% RESUME%] [PAUSE%] [-m PAUSE% RESUME%] [-t PAUSE% RESUME%] [-d %/TIMEOUT] [-e %/TIMEOUT]

-b --> reset battery stats on demand (does not work on all devices)

-c --> manually set charging control file config (/path/to/ctrl/file ON OFF)

-h --> cs usage instructions

-i --> display battery info

-r --> reset cs to its initial state

-s --> toggle auto-run; resume CS service

-v --> toggle verbose (extensive log -- debugging)

-x --> toggle store_mode/batt_slate_mode (Samsung); charging_enabled/battery_charging_enabled (others)

debug --> gather debugging data & save it to /sdcard/cs_debug.zip

just "cs" --> run CS with default/saved settings

-k LEVEL --> keep/maintain battery power at a constant LEVEL (pauses CS service)

PAUSE% RESUME% --> pause charging at PAUSE% value (default 90); resume if battery drops below RESUME% (default 80). This is the INITIAL SETUP COMMAND. If auto-run is OFF, the command works as is; else, new settings are saved and automatically picked up by CS service.

-m/-t PAUSE% RESUME% --> generate automation config (-m for MacroDroid; -t for Tasker -- pick one)

-d [%/TIMEOUT (optional)] --> disable charging on demand (pauses CS service)

-e [%/TIMEOUT (optional)] --> enable charging on demand (pauses CS service)


Usage Examples/Tips

"cs 85" --> pause charging at 85%; resume when battery level is less or equal to 80% (default).

"cs 80 20" --> pause charging at 80%; resume when battery level is less or equal to 20%.

"cs -d" --> disable charging.

"cs -d" --> enable charging. 

"cs -d 30m" --> keep charging disabled for 30 minutes.

"cs -e 1h" --> keep charging enabled for 1 hour. 

"cs -e 80%" --> Charge until battery level equals 80%.

"cs -d 40%" --> Charge until battery level equals 40%.

"cs -e 120 && cs -d 30m && cs -e 1h" --> charge for 120 seconds, pause for 30 minutes, then charge again for 1h.

"cs -e 30m && cs -d 30m && cs -e 90%" --> charge for 30 minutes, pause for 30 minutes, then charge again, but this time until battery level is greater or equal to 90%.

"cs -e 50% && cs -d 5h && cs -e 80% && cs -d 30m && cs -e 90%" --> charge until 50%, pause for 5 hours, charge until 80%, pause for 30 minutes, charge until 90%.

Ideally, you want your battery level between 40-60% - best, 20-80% - average, 10-90% - fair.

For best convenience, stick with cs 90 80; cs 80 70 for a perfect balance between convenience & battery wear. If you want the longest battery lifespan, aim for cs 45 40 (best for prolonged usage -- i.e., navigation).
EOD
echo
exit 0


# Disable charging on demand
elif [ "$1" = '-d' ]; then
	if auto_run && ! pause_svc; then
		touch $PersistDir/pause_svc
		echo -e "(i) CS service paused.\n"
	fi
	
	if n "$2"; then
		if echo "$2" | grep -q '%'; then OFF_percent $2; else OFF_time $2; fi
	else OFF_time; fi

	if auto_run && pause_svc; then
		echo -e "(i) Reboot the system or simply run \"cs -s\" to resume CS service.\n"
	fi
	exit 0


# Enable charging on demand
elif [ "$1" = '-e' ]; then
	if auto_run && ! pause_svc; then
		touch $PersistDir/pause_svc
		echo "(i) CS service paused.\n"
	fi
	
	invert_OFF=true
	if n "$2"; then
		if echo "$2" | grep -q '%'; then OFF_percent $2; else OFF_time $2; fi
	else OFF_time; fi
	
	if auto_run && pause_svc; then
		echo -e "(i) Reboot the system or simply run \"cs -s\" to resume CS service.\n"
	fi
	exit 0


# Battery & settings info
elif [ "$1" = '-i' ]; then
	is f $config || update_cfg
	echo 'Battery Info'
	cat "$uevent" | grep -Ev 'NAME|PRESENT|CAPACITY_LEVEL' \
		| sed 's/POWER_SUPPLY_//' \
		| sed 's/CAPACITY/LEVEL/' \
		| sed '/LEVEL=/s/$/%/' \
		| sed 's/_NOW//' \
		| sed '/RGE_R/s/GE/GING/'
	echo -e "\nCurrent Settings"
	cat $config
	if auto_run; then
		if pause_svc; then echo "service_status=PAUSED"
		else echo "service_status=ON"; fi
	else echo "service_status=OFF"; fi
	echo
	exit 0


# Run with default/saved settings
elif z "$1"; then
	if ! is f $config; then
		echo "(i) No settings found."
		echo "- Applying defaults -- cs 90 80..."
		update_cfg
		echo
		sleep 1
	fi
	if auto_run && ! pause_svc; then
		echo -e "(i) CS service is already running.\n"
		exit 0
	fi

	c_loop $higher_limit


# Generate MacroDroid & Tasker automation configs
elif [ "$1" = "-m" ] || [ "$1" = "-t" ]; then
	if echo "$1" | grep -q '\-m'; then
		echo "(i) Generating /sdcard/MacroDroid/charging_switch.category..."
		mdir=/sdcard/MacroDroid
		is d $mdir || mkdir -p $mdir
		cp /magisk/cs/config/macrodroid $mdir/charging_switch.category
		cd $mdir
		sed -i "s/:90/:$2/; s/:11/:$3/" charging_switch.category
	elif echo "$1" | grep -q '\-t'; then
		echo "(i) Generating /sdcard/Tasker/projects/charging_switch.prj.xml..."
		tdir=/sdcard/Tasker/projects
		is d $tdir || mkdir -p $tdir
		cp /magisk/cs/config/tasker $tdir/charging_switch.prj.xml
		cd $tdir
		sed -i "/<Int sr=\"arg0\" val=\"90\"\/>/s/90/$2/" charging_switch.prj.xml
		sed -i "/<rhs>90<\/rhs>/s/90/$2/" charging_switch.prj.xml
		sed -i "/<Int sr=\"arg1\" val=\"10\"\/>/s/10/$3/" charging_switch.prj.xml
		sed -i "/<rhs>10<\/rhs>/s/10/$3/" charging_switch.prj.xml
	else exxit
	fi
	echo -e "- Done.\n"
	exit 0


# Run with all parameters (initial setup)
elif echo "$1" | grep -q '[0-9]'; then
	if n "$2"; then update_cfg "$1" "$2"; else update_cfg "$1"; fi
	echo "(i) New settings saved."
	sleep 1

	if auto_run && ! pause_svc; then
		echo "- CS service is already running."
		echo -e "-- Now working with the new values.\n"
		switch_ON
		exit 0
	fi
	
	c_loop $1


else exxit
fi
